# WebXR VR 集成方案与开发策略

本文档记录基于 WebXR 的 VR 编辑体验的可行性、风险控制思路与推荐实现方式，便于后续查询与开发。

---

## 一、项目现状简要

- **技术栈**：Three.js（glTF/GLB、3D Tiles）、OrbitControls、射线选择（mesh/面）、右侧 2D DOM 面板做标注与设置。
- **核心操作**：加载模型、点选/框选、添加/编辑标注（标签、分类、颜色）、保存/加载到 Supabase。

---

## 二、WebXR VR 可行性结论

**技术上完全可行**，与现有架构契合：

1. **Three.js 官方支持 WebXR**  
   使用 `THREE.WebXRManager`，同一套 `scene`、`camera`、`renderer` 可在 2D 与 VR 间复用，VR 时由 XR 提供视图与相机位姿即可。

2. **Quest 3 与浏览器**  
   - Quest 3 上的 Meta Quest Browser 支持 WebXR `immersive-vr`。  
   - 使用 `navigator.xr.isSessionSupported('immersive-vr')` 检测支持；支持时调用 `session.requestSession({ mode: 'immersive-vr' })` 进入 VR。  
   - 部署需 **HTTPS**（现有 Vercel 已满足）。  
   - 多数浏览器要求 **用户手势**（如点击按钮）才能请求 XR 会话，因此更稳妥的体验是：打开网址 → 点击「进入 VR」→ 自动进入 VR。

3. **与现有逻辑的衔接**  
   场景、模型、标注数据结构均可复用；需要新增/改动的主要是：**相机与控制器输入**、**交互方式**、**VR 下的 UI**。

---

## 三、需要提前考虑的点

| 方面           | 现状                 | VR 下要考虑的                                           |
|----------------|----------------------|---------------------------------------------------------|
| 相机与控制     | OrbitControls + 鼠标 | 头显位姿驱动相机；移动可用 teleport 或摇杆，旋转随头动。 |
| 选择           | 鼠标射线 + 单击/Shift 多选 | 用手柄射线（或手部追踪）做“指哪选哪”；多选可用长按或 VR 内勾选。 |
| 标注 UI        | 右侧 2D 面板         | 在 VR 里做 3D UI（悬浮面板 + 射线点击），或虚拟屏幕投 2D 页面。 |
| 性能           | 桌面端               | Quest 需稳定 72/90fps 双屏，3D Tiles 的 LOD 可能需在 VR 下调保守。 |
| 输入           | 键盘（WASD 等）      | VR 无键盘，飞行/移动改为手柄摇杆或 teleport。            |

---

## 四、“用 Quest 3 打开网址自动进 VR”的可行方式

- **完全自动（无任何点击）**：多数浏览器不允许在无用户手势时调用 `requestSession()`，因此“一打开就自动进 VR”在标准 WebXR 下通常 **不可行**。  
  可行替代：检测到在 Quest 浏览器内时，页面中央显示大按钮「进入 VR」，用户点一次即进入（“半自动”）。

- **推荐做法**：  
  - 用 `navigator.xr.isSessionSupported('immersive-vr')` 判断支持；  
  - 若支持，可显示「进入 VR」按钮（在 Quest 上可自动显示并突出）；  
  - 用户点击一次后进入 VR，符合规范且体验清晰。

---

## 五、风险控制：可插拔的 VR 层

### 5.1 为何要“独立一层”

- **缠在一起**：在 `main.js` 里到处写 `if (xrSession) { ... } else { ... }`，相机、射线、UI 与 VR 混在一起。将来删 VR 要在大量代码里拆，容易漏、容易坏，**风险高**。
- **独立一层**：  
  - 所有 WebXR 相关代码集中在一个（或少数几个）模块，例如 `js/webxr-vr.js` 或 `js/vr/` 目录。  
  - 该层只负责：申请/结束 XR 会话、用头显/手柄更新相机和射线、把“VR 里的选择/点击”转成与现有逻辑一致的接口（如“当前选中的 mesh/面”）。  
  - `main.js` 只在少数几处调用，例如：初始化时 `if (wantVR && supportsVR) VRLayer.init(renderer, scene, camera)`，渲染循环里 `if (VRLayer.active) VRLayer.update()`。  
  → 将来若不再需要 VR：**删除 VR 模块 + 删除这几处调用**即可，**风险可控**。

### 5.2 删除 VR 时的操作

- 删除 VR 相关文件（如 `js/webxr-vr.js` 或 `js/vr/`）。  
- 在 `main.js` 中移除：  
  - VR 的 `init` 调用；  
  - 渲染循环中的 `VRLayer.update()`（或等价逻辑）；  
  - 若有「进入 VR」按钮，移除按钮与事件绑定。  
- 无需在业务逻辑里到处删 `if (xrSession)` 分支。

---

## 六、开发策略：同一代码库 + 可选 VR 层

### 6.1 不推荐：完全独立的 VR 项目再整合

- 需要复制/重写场景、模型加载、标注状态、保存逻辑，两套代码会逐渐分化。  
- 日后“整合”实为合并两棵不同的树，冲突多、易出错，**整合风险大**。

### 6.2 推荐：同一代码库、VR 以可选模块存在

- 在 **feature 分支** 中开发，新增 **只依赖现有 scene / camera / renderer / 标注状态** 的 VR 层，不复制业务逻辑。  
- 2D 逻辑尽量不改，仅在“VR 模式”下由 VR 层接管相机与输入。  
- 体验不好时：不合并 VR 分支，或合并后用开关关闭 VR 入口；若要彻底去掉，按 5.2 删除即可。  
- 没有“两套系统再整合”的合并风险，只有“加一层、以后可整块拿掉”的风险，且通过“独立一层”已控制。

### 6.3 小结

- **“将来想删掉 VR”**：不危险，前提是 **VR 从一开始就做成独立的一层**（单独文件/目录、少量清晰入口）；删除 = 删这一层 + 几处调用。  
- **“分开做再整合”**：单独做一个完整 VR 项目再合并，整合风险更大；更稳妥的是 **同一代码库、在分支里只加“VR 层”**，验证体验后再决定长期保留、用开关关闭，或整层删除。

---

## 七、建议实现阶段（供开发时参考）

1. **Phase 1**：在现有 Three 场景上接入 WebXR，只做「进入/退出 VR + 头显位姿驱动相机」，先在头盔里“看着同一场景转悠”，不做复杂交互。  
2. **Phase 2**：把手柄射线接上，用射线做 mesh/面选择，复用现有选中高亮与标注数据结构。  
3. **Phase 3**：VR 内标注流程——或 3D 面板（标签、分类、颜色、确认），或虚拟屏幕 + 现有 2D 页面。  
4. **Phase 4**：性能与体验（LOD、帧率、teleport/移动方式、多选交互等）。

---

## 八、后续可细化内容

- VR 层的具体接口设计：例如 `init(renderer, scene, camera)`、`update()`、以及如何把“VR 选中”传回现有选择逻辑。  
- 「进入 VR」按钮的展示逻辑（含 Quest 检测与降级）。  
- VR 下的 3D UI 与 2D 投屏方案选型。

---

*文档版本：初稿，便于后续查询与开发时对照。*
